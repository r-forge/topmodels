\documentclass[11pt,t,usepdftitle=false,aspectratio=169]{beamer}
\usetheme[url,license]{uibk}

\title{Distributional Regression Forests\\ for Probabilistic Modeling and Forecasting}
\author{Achim Zeileis, Lisa Schlosser, Moritz N. Lang, \\
Torsten~Hothorn, Georg~J.~Mayr, Reto Stauffer}
\setbeamerfont{url}{size*={11.5pt}{13pt},series=\mdseries}
\URL{http://www.partykit.org/partykit/}
\renewcommand{\headerimage}[1]{%
   \IfStrEqCase{#1}{%
      {1}{%
         \gdef\myheaderimageid{#1}%
         \gdef\myheaderimageposition{nw}%
         \gdef\myheaderimage{forest.jpg}%
      }}[%
         \gdef\myheaderimageid{1}%
         \gdef\myheaderimageposition{nw}%
         \gdef\myheaderimage{forest.jpg}%
      ]%
}
\headerimage{1}

%% Create new footer line
\setbeamertemplate{footline}{
  \hfill \vspace*{1.em}  \insertframenumber{} / \inserttotalframenumber \hspace*{1ex} {\tiny \ccLogo \ccAttribution} \hspace*{2ex}
}
\usepackage{ccicons}


\graphicspath{{Figures/}}
\usepackage[utf8]{inputenc}

\setbeamertemplate{caption}{\insertcaption} 
%% includes a replacement for \usepackage{Sweave}
% \usepackage{Sweave}
\usepackage{changepage}
\usepackage{amsmath,tikz}
\usepackage{calc}
\usepackage{graphicx}
\usetikzlibrary{positioning,shapes,arrows,decorations.pathreplacing,calc,automata,mindmap,trees,tikzmark,decorations.pathreplacing}
\usepackage{xcolor}
%\usepackage[cal=boondoxo]{mathalfa}
%\graphicspath{{plots/}}
\newcommand{\argmax}{\operatorname{argmax}\displaylimits}

%% colors
\definecolor{HighlightOrange}{rgb}{0.9490196,0.5725490,0.0000000}
\definecolor{HighlightBlue}{rgb}{0.4784314,0.7490196,0.9803922}
\definecolor{forestred}{RGB}{206,73,81}
\definecolor{treegreen}{RGB}{0,143,0}
\definecolor{lightblue}{RGB}{34,151,230}
\definecolor{lightorange}{RGB}{255,165,0}

\SweaveOpts{engine=R, eps=FALSE, keep.source=TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
options(prompt = "R> ", continue = "+  ", useFancyQuotes = FALSE, width = 70)

set.seed(7)

invisible(.Call(grDevices:::C_palette, grDevices::hcl(
  h = c(0,   5, 125, 245, 195, 315,  65,   0),
  c = c(0, 100,  90,  85,  63, 105,  90,   0),
  l = c(0,  55,  75,  60,  82,  48,  80,  65)
)))

# setwd("~/svn/partykit/pkg/disttree/inst/dissertation_overview/slides/")
library("disttree")
library("Formula")
library("latex2exp")
library("gamlss")
library("lattice")
library("crch")
library("RainTyrol")
library("parallel")
library("gamlss.cens")
gen.cens(NO, type = "left")
library("ggplot2")
theme_set(theme_bw(base_size = 18))

## HCL palette
pal <- hcl(c(10, 128, 260, 290, 50), 100, 50)
names(pal) <- c("forest", "tree", "gamlss", "gamboostLSS", "EMOS")

pallight <- hcl(c(10, 128, 260, 290, 70), 100, 50, alpha = 0.25)
names(pallight) <- c("forest", "tree", "gamlss", "gamboostLSS", "EMOS")

transpgray <- rgb(0.190,0.190,0.190, alpha = 0.2)
@




\begin{document}
\SweaveOpts{concordance=FALSE}

\section{Distributional Regression Forests for Probabilistic Modeling and Forecasting}


\subsection{Motivation}

\begin{frame}%[fragile]
\frametitle{Motivation}
\vspace{-0.41cm}
\begin{figure}[!htb]
\minipage{0.285\textwidth}
\begin{center}
<<motivation_GLM, echo=FALSE, results=hide>>=
nobs <- 200
## GLM
set.seed(7)
x <- c(1:nobs)/nobs
ytrue <- 1+x*1.5
y <- ytrue + rnorm(nobs,0,0.3)
@
\visible<2->{
<<plot_motivation_GLM, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(y=y , x=x, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
lines(x = x, y = ytrue, col = pal["forest"], lwd = 7, main = "")
@
}
\end{center}
\endminipage
\visible<3->{{\LARGE$\rightarrow$}}
\minipage{0.285\textwidth}
\begin{center}
<<motivation_GAM, echo=FALSE, results=hide>>=
## GAM
set.seed(7)
x <- c(1:nobs)/nobs
x <- 2*(x-0.5)
ytrue <- x^3 
y <- ytrue + rnorm(nobs,0,0.3)
@
\visible<3->{
<<plot_motivation_GAM, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(y=y , x=x, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
lines(x = x, y = ytrue, col = pal["forest"], lwd = 7, main = "")
@
}
\end{center}
\endminipage
\visible<4->{{\LARGE$\rightarrow$}}
\minipage{0.285\textwidth}
\begin{center}
<<motivation_GAMLSS, echo=FALSE, results=hide>>=
## GAMLSS
set.seed(7)
x <- c(1:nobs)/nobs
x <- 2*(x-0.5)
ytrue <- x^3
var <- exp(-(2*x)^2)/2
y <- ytrue + rnorm(nobs, 0, 0.1 + var)
@
\visible<4->{
<<plot_motivation_GAMLSS, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x, y, xaxt = "n", yaxt = "n", ann = FALSE, type = "n")
polygon(c(x, rev(x)), c(ytrue + 0.1 + var, rev(ytrue - 0.1 - var)),
  col = pallight["forest"], border = "transparent")
lines(x, ytrue, col = pal["forest"], lwd=7)
points(x, y, col = "slategray", pch = 19)
box(lwd = 5)
@
}
\end{center}
\endminipage

\vspace{0.5cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<2->{
LM, GLM\\
\vspace{0.5cm}
\code{lm}\\
\code{glm}\\
\vspace{1.5cm}}
\end{center}
\endminipage
\hspace{1.1cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<3->{
GAM\\
\vspace{0.5cm}
\code{mgcv}\\
\code{VGAM}\\
\vspace{1.5cm}}
\end{center}
\endminipage
\hspace{1.1cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<4->{
GAMLSS\\
\vspace{0.5cm}
\code{gamlss}\\
\code{mgcv}\\
\code{VGAM}\\
\code{gamboostLSS}\\
\code{bamlss}}
\end{center}
\endminipage
\end{figure}
\end{frame}




\begin{frame}[fragile]
\frametitle{Motivation}
\vspace{-0.41cm}
\begin{figure}[!htb]
\minipage{0.285\textwidth}
\begin{center}
<<motivation_regtree, echo=FALSE, results=hide>>=
## Reg. Tree
set.seed(7)
kappa <- 12
x <- c(1:nobs)/nobs
ytrue <- ytree <- yforest <- numeric(length = length(x))
for(i in 1:nobs) ytrue[i] <- if(x[i]<1/3) 0.5 else 1+(1-plogis(kappa*(2*(x[i]-0.2)-1)))
y <- ytrue + rnorm(nobs,0,0.3)
for(i in 1:nobs) ytree[i] <- if(x[i]<1/3) 0.5 else {if(x[i]<2/3) 2 else 1}
@
\visible<1->{
<<plot_motivation_regtree, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x = x, y = y, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
#lines(x = x, y = ytrue, col = "gray", lwd=5, main = "")
lines(x = x, y = ytree, col = pal["forest"], lwd=7)
@
}
\end{center}

\endminipage
\visible<2->{{\LARGE$\rightarrow$}}
\minipage{0.285\textwidth}
 \begin{center}
<<motivation_randforest, echo=FALSE, results=hide>>=
## Random Forest
for(i in 1:nobs) yforest[i] <- if(x[i]<0.27) 0.5 else { if(x[i]<0.39) 0.5 + 1.5*(plogis((x[i]-0.33)/6*700)) else 1+(1-plogis(kappa*(2*(x[i]-0.2)-1)))}
@
\visible<2->{
<<plot_motivation_randforest, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x = x, y = y, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
#lines(x = x, y = ytrue, col = "gray", lwd=5, main = "")
lines(x = x, y = yforest, col = pal["forest"], lwd=7, main = "")
@
}
\end{center}

\endminipage
\visible<3->{{\LARGE$\rightarrow$}}
\minipage{0.285\textwidth}
\begin{center}
\visible<3->{
<<plot_motivation_question, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x = x, y = y, xaxt="n", yaxt="n", ann=FALSE, type = "n")
box(lwd=5)
text(x = mean(range(x)), y = mean(range(y)), "?", cex = 12)
@
}
\end{center}

\endminipage

\minipage{0.285\textwidth}
\begin{center}
\vspace{0.0cm}
\visible<1->{
Regression tree\\
\vspace{0.3cm}
\resizebox{0.2\textwidth}{!}{
\begin{tikzpicture}
  \node[ellipse, fill=HighlightBlue!70, align=center] (n0) at (1, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n1) at (0.5, 1) {};
  \draw[-, line width=1pt] (n0) -- (n1);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n2) at (1.5, 1) {};
  \draw[-, line width=1pt] (n0) -- (n2);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n3) at (1, 0) {};
  \draw[-, line width=1pt] (n2) -- (n3);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n4) at (2, 0) {};
  \draw[-, line width=1pt] (n2) -- (n4);
\end{tikzpicture}}
\vspace{0.2cm}\\
\code{rpart}\\
\code{party(kit)}\\
\vspace{1cm}}
\end{center}
\endminipage
\hspace{0.65cm}
\minipage{0.285\textwidth}
\begin{center}
\vspace{-0.4cm}
\visible<2->{
Random forest\\
\vspace{0.4cm}
\resizebox{0.6\textwidth}{!}{
\begin{tikzpicture}
  \node[ellipse, fill=HighlightBlue!70, align=center] (n00) at (1, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n01) at (0.5, 1) {};
  \draw[-, line width=1pt] (n00) -- (n01);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n02) at (1.5, 1) {};
  \draw[-, line width=1pt] (n00) -- (n02);
  
  \node[ellipse, fill=HighlightBlue!70, align=center] (n10) at (3, 2) {};
  \node[ellipse, fill=HighlightBlue!70, align=center] (n11) at (2.5, 1) {};
  \draw[-, line width=1pt] (n10) -- (n11);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n12) at (3.5, 1) {};
  \draw[-, line width=1pt] (n10) -- (n12);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n13) at (2, 0) {};
  \draw[-, line width=1pt] (n11) -- (n13);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n14) at (2.8, 0) {};
  \draw[-, line width=1pt] (n11) -- (n14);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n15) at (3.2, 0) {};
  \draw[-, line width=1pt] (n12) -- (n15);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n16) at (4, 0) {};
  \draw[-, line width=1pt] (n12) -- (n16);
  
  \node[ellipse, fill=HighlightBlue!70, align=center] (n20) at (5, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n21) at (4.5, 1) {};
  \draw[-, line width=1pt] (n20) -- (n21);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n22) at (5.5, 1) {};
  \draw[-, line width=1pt] (n20) -- (n22);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n23) at (5, 0) {};
  \draw[-, line width=1pt] (n22) -- (n23);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n24) at (6, 0) {};
  \draw[-, line width=1pt] (n22) -- (n24);
\end{tikzpicture}
}
\vspace{0.3cm}\\
\code{randomForest}\\
\code{ranger}\\
\code{party(kit)}}
\end{center}
\endminipage
\hspace{0.65cm}
\minipage{0.285\textwidth}
\begin{center}
\vspace{0.15cm}
\visible<3->{
Distributional trees and forests\\
\vspace{1.15cm}
\code{disttree}\\
based on \code{partykit}\\
\vspace{1cm}}
\end{center}
\endminipage
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Motivation}

\textbf{Distributional:}
\begin{itemize}
  \item Specify the complete probability distribution (location, scale, shape, \dots).
\end{itemize}

\medskip

\textbf{Tree:}
\begin{itemize}
  \item Automatic detection of steps and abrupt changes. %(data driven)
  \item Capture non-linear and non-additive effects and interactions.
\end{itemize}

\medskip

\textbf{Forest:}
\begin{itemize}
  \item Smoother effects.
  \item Stabilization and regularization of the model.
\end{itemize}
\end{frame}




\subsection{Distributional trees}

<<treedata, echo=FALSE, results=hide>>=
set.seed(54)
nobs <- 500
x <- runif(nobs, 0, 1)
mu <- sigma <- ytrue <- numeric(length = nobs)
for(i in 1:nobs) sigma[i] <- if(x[i]<=0.4) 1 else 3
for(i in 1:nobs) mu[i] <- if(x[i]<= 0.4|| x[i]>0.8) 4 else 12
y <- rnorm(nobs, mean = mu, sd = sigma)
ytrue <- mu
data <- data.frame(cbind(y,x, ytrue))

alldata <- cbind(data, mu, sigma)
odata <- alldata[order(alldata["x"]),]
@

<<dgp_tree, echo=FALSE, results=hide>>=
data <- data.frame(x = numeric(0), x = numeric(0), x = numeric(0))
names(data) <- c("x","x","x")
fig <- party(
  partynode(1L,
            split = partysplit(2L, breaks = 0.4),
            kids = list(
              partynode(2L, info = c(
                "n = 200",
                "   True parameters:   ",
                expression(mu == '4'),
                expression(sigma == '1')
              )),
              partynode(3L,
                        split = partysplit(3L, breaks = 0.8),
                        kids = list(
                          partynode(4L, info = c(
                            "n = 200",
                            "   True parameters:   ",
                            expression(mu == '12'),
                            expression(sigma == '3')
                          )),
                          partynode(5L, info = c(
                            "n = 100",
                            "   True parameters:   ",
                            expression(mu == '4'),
                            expression(sigma == '3')
                          )))))),
  data
)


node_inner_ext <- function (obj, id = TRUE, pval = TRUE, abbreviate = FALSE, fill = "white", 
    gp = gpar()) 
{
    meta <- obj$data
    nam <- names(obj)
    extract_label <- function(node) {
        if (is.terminal(node)) 
            return(rep.int("", 2L))
        varlab <- character_split(split_node(node), meta)$name
        if (abbreviate > 0L) 
            varlab <- abbreviate(varlab, as.integer(abbreviate))
        if (pval) {
            nullna <- function(x) is.null(x) || is.na(x)
            pval <- suppressWarnings(try(!nullna(info_node(node)$p.value), 
                silent = TRUE))
            pval <- if (inherits(pval, "try-error")) 
                FALSE
            else pval
        }
        if (pval) {
            pvalue <- node$info$p.value
            plab <- ifelse(pvalue < 10^(-3L), paste("p <", 10^(-3L)), 
                paste("p =", round(pvalue, digits = 3L)))
        }
        else {
            plab <- ""
        }
        return(c(varlab, plab))
    }
    maxstr <- function(node) {
        lab <- extract_label(node)
        klab <- if (is.terminal(node)) 
            ""
        else unlist(lapply(kids_node(node), maxstr))
        lab <- c(lab, klab)
        lab <- unlist(lapply(lab, function(x) strsplit(x, "\n")))
        lab <- lab[which.max(nchar(lab))]
        if (length(lab) < 1L) 
            lab <- ""
        return(lab)
    }
    nstr <- maxstr(node_party(obj))
    if (nchar(nstr) < 6) 
        nstr <- "aAAAAa"
    rval <- function(node) {
        node_vp <- viewport(x = unit(0.5, "npc"), y = unit(0.5, 
            "npc"), width = unit(1, "strwidth", nstr) * 1.3, 
            height = unit(3, "lines"), name = paste("node_inner", 
                id_node(node), sep = ""), gp = gp)
        pushViewport(node_vp)
        xell <- c(seq(0, 0.2, by = 0.01), seq(0.2, 0.8, by = 0.05), 
            seq(0.8, 1, by = 0.01))
        yell <- sqrt(xell * (1 - xell))
        xell <- xell*1.11 - 0.055             # to adapt size of the ellipse to the size with p-value
        lab <- extract_label(node)
        fill <- rep(fill, length.out = 2L)
        grid.polygon(x = unit(c(xell, rev(xell)), "npc"), y = unit(c(yell, 
            -yell) + 0.5, "npc"), gp = gpar(fill = fill[1]))
        grid.text(lab[1L], y = unit(1.5 + 0.5,                  # to adapt position of x to its position with p-value
            "lines"))
        #grid.text(lab[1L], y = unit(1.5 + 0.5 * (lab[2L] != ""), 
        #    "lines"))
        grid.text(lab[2L], y = unit(1, "lines"))
        if (id) {
            nodeIDvp <- viewport(x = unit(0.5, "npc"), y = unit(1, 
                "npc"), width = max(unit(1, "lines"), unit(1.3, 
                "strwidth", nam[id_node(node)])), height = max(unit(1, 
                "lines"), unit(1.3, "strheight", nam[id_node(node)])))
            pushViewport(nodeIDvp)
            grid.rect(gp = gpar(fill = fill[2]))
            grid.text(nam[id_node(node)])
            popViewport()
        }
        upViewport()
    }
    return(rval)
}

class(node_inner_ext) <- "grapcon_generator"

@

\begin{frame}[fragile]
\frametitle{Distributional trees}
\vspace*{-0.12cm}
\begin{center} 
DGP:  $\; Y\ |\ X = x \; \sim  \; \mathcal{N}(\mu(x), \sigma^2(x))$

\vspace*{-0.21cm}
\setkeys{Gin}{width=0.58\linewidth}
<<plottree_xyplot, fig=TRUE, echo=FALSE,width=7>>=
par(mar=c(5.1,4.1,2.4,1.1))
plot(y=odata$y, x=odata$x, ylab = "y", xlab = "x", col = "gray")
lines(x = odata$x, y = odata$mu, col = pal["forest"], lwd = 2.5, main = "")
polygon(c(odata$x, rev(odata$x)), c(odata$mu + odata$sigma, rev(odata$mu - odata$sigma)),
  col = pallight["forest"], border = "transparent")
legend("topleft", expression(mu  %+-%  sigma), bty = "n")
@
\end{center}
\end{frame}


\begin{frame}
\frametitle{Distributional trees}
\vspace*{-0.12cm}
\begin{center} 
DGP:  $\; Y\ |\ X = x \; \sim  \; \mathcal{N}(\mu(x), \sigma^2(x))$

\vspace*{-0.21cm}
\setkeys{Gin}{width=0.5\linewidth}
<<plottree_dgp, fig=TRUE, echo=FALSE>>=
paltrees <- rgb(c(0.97, 0.64, 1), c(0.70, 0.83, 1), c(0.30, 0.99, 1))
plot(fig, inner_panel = node_inner_ext,
     tp_args = list(FUN = identity, width = 18, fill = paltrees[c(1, 3)]), 
     ip_args = list(fill = paltrees[c(2, 3)]),
     drop_terminal = TRUE, tnex = 1.7)
@
\end{center}
\end{frame}

<<tree, echo=FALSE, results=hide>>=
set.seed(7)
nobs <- 500
x <- runif(nobs, 0, 1)
mu <- sigma <- ytrue <- numeric(length = nobs)
for(i in 1:nobs) sigma[i] <- if(x[i]<=0.4) 1 else 3
for(i in 1:nobs) mu[i] <- if(x[i]<= 0.4|| x[i]>0.8) 4 else 12
y <- rnorm(nobs, mean = mu, sd = sigma)
#y <- rcnorm(nobs, mean = mu, sd = sigma, left = 0)
ytrue <- mu
data <- data.frame(cbind(y,x, ytrue))
tree <- disttree(y ~ x, data = data, family = NO(), type.tree = "mob")
#tree <- disttree(y ~ x, data = data, family = dist_list_cens_normal)
@

\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.5\linewidth}
<<plottree_estpar, fig=TRUE, echo=FALSE>>=
# function for output in terminal panels
FUN <- function (x) 
{
  cf <- x$coefficients
  cf <- matrix(cf, ncol = 1, dimnames = list(names(cf), ""))
  c(sprintf("n = %s", x$nobs), "Estimated parameters:", parse(text = paste0("mu == '", format(round(cf[1], 2), nsmall = 2), "'")), 
                                                        parse(text = paste0("sigma == '", format(round(cf[2], 2), nsmall = 2), "'")))
}

paltrees <- rgb(c(0.97, 0.64, 1), c(0.70, 0.83, 1), c(0.30, 0.99, 1))

## plot version using FUN and tree of class 'disttree'
plot(tree, drop = TRUE, tnex = 1.7, FUN = FUN,
     tp_args = list(fill = paltrees[c(1, 3)], width = 18), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}


\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.5\linewidth}
<<plottree_box, fig=TRUE, echo=FALSE>>=
plot(as.constparty(tree), tnex = 1.7, drop = TRUE,
     tp_args = list(fill = paltrees[c(1, 3)], ylines = 1.5), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}



\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.5\linewidth}
<<plottree_dens, fig=TRUE, echo=FALSE>>=
node_density <- function (tree, xscale = NULL, yscale = NULL, horizontal = FALSE,
                          main = "", xlab = "", ylab = "Density", id = TRUE, rug = TRUE,
                          fill = paltrees[c(1, 3)], col = "black", lwd = 0.5, ...) 
{
  yobs <- tree$data[,as.character(tree$info$formula[[2]])]
  ylines <- 1.5
  if (is.null(xscale)) xscale <- c(-5.1,22.5)
  if (is.null(yscale)) yscale <- c(-0.05,0.45)
  xr <- xscale
  yr <- yscale
  
  if (horizontal) {
    yyy <- xscale
    xscale <- yscale
    yscale <- yyy
  }
  
  rval <- function(node) {
    yrange <- seq(from = -20, to = 90)/4
    ydens <- node$info$object$ddist(yrange)
    
    top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
                                            widths = unit(c(ylines, 1, 1), c("lines", "null", "lines")), 
                                            heights = unit(c(1, 1), c("lines", "null"))), 
                       width = unit(1, "npc"), 
                       height = unit(1, "npc") - unit(2, "lines"), 
                       name = paste("node_density",node$id, sep = ""))
    pushViewport(top_vp)
    grid.rect(gp = gpar(fill = "white", col = 0))
    top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
    pushViewport(top)
    mainlab <- paste(ifelse(id, paste("Node", node$id, "(n = "), "n = "), node$info$nobs, ifelse(id, ")", ""), sep = "")
    
    grid.text(mainlab)
    popViewport()
    plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
                     xscale = xscale, yscale = yscale, 
                     name = paste("node_density",  node$id, "plot", sep = ""))
    pushViewport(plot)
    yd <- ydens
    xd <- yrange
    if (horizontal) {
      yyy <- xd
      xd <- yd
      yd <- yyy
      yyy <- xr
      xr <- yr
      yr <- yyy
      rxd <- rep(0, length(xd))
      ryd <- rev(yd)
    } else {
      rxd <- rev(xd)
      ryd <- rep(0, length(yd))
    }
    
    if (rug) {
      nodeobs <- node$info$object$y
      if (horizontal) {
        grid.rect(x = xscale[1], y = nodeobs , height = 0, width = xscale[1], 
                  default.units = "native", just = c("right", "bottom"),
		  gp = gpar(lwd = 2, col = gray(0, alpha = 0.18)))
      } else {
        grid.rect(x = nodeobs, y = yscale[1], 
                  width = 0, height = abs(yscale[1]), default.units = "native", 
                  just = c("center", "bottom"),
		  gp = gpar(lwd = 2, col = gray(0, alpha = 0.18)))
        #grid.lines(x = xr, y = yr, gp = gpar(col = "lightgray"), 
        #           default.units = "native")
        #grid.lines(x = xr, y = yr, gp = gpar(col = "lightgray"), 
        #           default.units = "native")
      }
    }

    
    grid.polygon(x = c(xd, rxd), y = c(yd, ryd), default.units = "native",
              gp = gpar(col = "black", fill = fill, lwd = lwd))
    #grid.lines(x = xd, y = yd, default.units = "native", 
    #           gp = gpar(col = col, lwd = lwd))
    grid.xaxis()
    grid.yaxis()
    grid.rect(gp = gpar(fill = "transparent"))
    upViewport(2)
  }
  return(rval)
}

class(node_density) <- "grapcon_generator"

plot(tree, tnex = 1.7, drop = TRUE,
     terminal_panel = node_density,
     tp_args = list(fill = paltrees[c(1, 3)]), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}
%\begin{frame}
%\frametitle{Distributional trees}
%\center
%\vspace*{-1cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{tree_box}
%\end{frame}



\subsection{Learning}

\begin{frame}
\frametitle{Learning distributional trees and forests}
\begin{minipage}{0.7\textwidth}
{\bf Tree:}
\begin{enumerate}
\item<3-> Fit global distributional model $\mathcal{D}(Y; \theta)$: \\ % to the whole data set:\\
Estimate $\hat{\theta}$ via maximum likelihood \\
$\hat{\theta} = \argmax_{\theta \in \Theta} \sum_{i=1}^n \ell(\theta; y_i)$
\item<7-> Test for associations/instabilities of the scores $\frac{\partial \ell}{\partial \theta}(\hat{\theta};y_i)$ and each covariate $X_i$.
\end{enumerate}
\end{minipage}
\begin{minipage}{0.23\textwidth}
%\vspace{-0.1cm}
\begin{tikzpicture}
\visible<2-3>{
\node[ellipse, fill=HighlightBlue!70, align=center, scale = 0.7, minimum width=60pt, minimum height = 30pt] (n0) at (0.8, 1.7) {$Y$};
}
\visible<4>{
\node[ellipse, fill=HighlightBlue!70, align=center, scale = 0.7, minimum width=60pt, minimum height = 30pt] (n0) at (0.8, 1.7) {$\mathcal{D}(Y;\hat{\theta}$)};
}
\visible<5->{
\node[inner sep=0pt] (density1) at (0.8, 1.7)
{\includegraphics[width=0.6\textwidth]{density1.jpeg}};
}
\visible<6-8>{
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n1) at (0, 0) {?};
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n2) at (1.6, 0) {?};
\draw[-, gray, line width=0.5pt] (0.7, 1) -- (n1);
\draw[-, gray, line width=0.5pt] (0.9, 1) -- (n2);
}
\visible<9-10>{
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n1) at (0, 0) {$Y_1$};
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n2) at (1.6, 0) {$Y_2$};
\draw[-, gray, line width=0.5pt] (0.7, 1) -- (n1) node [midway, left] {\scriptsize $X \leq p$};
\draw[-, gray, line width=0.5pt] (0.9, 1) -- (n2) node [midway, right] {\scriptsize $X > p$};
}
\visible<11>{
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n1) at (0, 0) {$\mathcal{D}(Y_1;\hat{\theta_1}$)};
\node[rectangle, fill=HighlightOrange!70, align=center, scale = 0.7, minimum width=50pt, minimum height = 20pt] (n2) at (1.6, 0) {$\mathcal{D}(Y_2;\hat{\theta_2}$)};
}
\visible<11->{
\draw[-, gray, line width=0.5pt] (0.7, 1) -- (n1) node [midway, left] {\scriptsize $X \leq p$};
\draw[-, gray, line width=0.5pt] (0.9, 1) -- (n2) node [midway, right] {\scriptsize $X > p$};
}
\visible<12->{
\node[inner sep=0pt] (density2) at (-0.1,-0.1)
{\includegraphics[width=0.5\textwidth]{density2.jpeg}};
}
\visible<12->{
\node[inner sep=0pt] (density3) at (1.7,-0.1)
{\includegraphics[width=0.5\textwidth]{density3.jpeg}};
}
\end{tikzpicture}
\end{minipage}
\vspace{0.1cm}
%\begin{adjustwidth}{-0.0em}{-1em}
\begin{enumerate}
\setcounter{enumi}{2}
\item<8-> Split along the covariate $X$ with strongest association or instability and at breakpoint $p$ with highest improvement in log-likelihood.
\item<10-> Repeat steps 1--3 recursively until some stopping criterion \\
is met, yielding $B$ subgroups $\mathcal{B}_b$ with $b = 1, \dots, B$.
\end{enumerate}
%\end{adjustwidth}
\vspace{0.4cm}
\visible<13->{
{\bf Forest:} Ensemble of $T$ trees.
\begin{itemize}
\item Bootstrap or subsamples.
\item Random input variable sampling.
\end{itemize}
}
\end{frame}


\begin{frame}
\frametitle{Adaptive local likelihood estimation}

\textbf{Parameter estimator} for \only<1-3>{\textbf{a global}}\only<4->{\textbf{an adaptive local}}\\ model with learning data \only<1>{$\{y_i\}_{i=1,\ldots,n}$}\only<2->{$\{(y_i,\bold{x}_i)\}_{i=1,\ldots,n}$} :

\[
\hat{\theta}\visible<2->{(\bold{x})} =  \argmax_{\theta \in \Theta} \sum_{i=1}^n \visible<2->{w_i(\bold{x}) \cdot} \ell(\theta; y_i)
\]

\medskip

\visible<3->{
\textbf{Weights:}
\begin{eqnarray*}
w^{\text{base}}_i(\bold{x})   & = & 1 \\[0.2cm]
\visible<4->{
w^{\text{tree}}_i(\bold{x})   & = & \sum_{b=1}^B I((\bold{x}_i \in \mathcal{B}_b) \land (\bold{x} \in \mathcal{B}_b)) \\[0.1cm]
\visible<5->{
w^{\text{forest}}_i(\bold{x}) & = & \frac{1}{T} \sum_{t=1}^T \sum_{b=1}^{B^t} \frac{I((\bold{x}_i \in \mathcal{B}^t_b) \land (\bold{x} \in \mathcal{B}^t_b))}{|\mathcal{B}^t_b|}
\end{eqnarray*}
}}}
\end{frame}




\subsection{Weather forecasting}

\begin{frame}[fragile]
\frametitle{Weather forecasting}

\textbf{Goal:}

\medskip

\begin{center}
\begin{tikzpicture}
\draw[->] (0.4,0)--(0.9,0);
\draw[] (1,-0.4) rectangle (2.5,0.4);
\node[font=\scriptsize] at (1.75,0) {nature};
\draw[->] (2.6,0)--(3.1,0);
\visible<1>{%
\node[] at (0.0,0) {X};
\node[] at (3.5,0) {Y};}
\visible<2->{%
\node[inner sep=0pt] (today) at (-2.3,-0.4)
{\includegraphics[width=.365\textwidth]{today.png}};
\node[font=\scriptsize] at (-2.3,-2.4) {2018-03-15};
\node[inner sep=0pt] (future) at (5.8,-0.4)
{\includegraphics[width=.365\textwidth]{future.png}};
\node[font=\scriptsize] at (5.8,-2.4) {2018-03-16};}
\end{tikzpicture}
\end{center}

%% https://innsbruck-airport.panomax.com/

\only<1-2>{%
\textbf{Data:}
\begin{itemize}
\item X: State of the atmosphere now (temperature, precipitation, wind, \dots).
\item Y: State of the atmosphere in the future (hours, days, weeks, \dots).
\end{itemize}}%
\only<3->{%
\textbf{Two stages:}
\begin{itemize}
\item Physical model: Numerical weather prediction (NWP).
\item Statistical model: Model output statistics (MOS).
\end{itemize}}

\end{frame}


\begin{frame}[fragile]
\frametitle{Weather forecasting}

\textbf{NWP:}
\begin{itemize}
  \item Based on a physical model.
  \item Massive numerical simulation of atmospheric processes.
  \item Here: Global model on a $50\times 50 \text{km}^2$ grid.
\end{itemize}

\medskip

\textbf{Problem:} Uncertain initial conditions, unresolved processes.

\medskip

\textbf{Solution:} Ensemble of simulation runs under perturbed conditions.

\end{frame}



<<echo = FALSE, results=hide>>=
library("zoo")

Sys.setenv("TZ"="UTC")

# -------------------------------------------------------------------
# GFS ensemble forecast
# -------------------------------------------------------------------

GFS   <- read.table("Data/GENS_00_innsbruck-flughafen.txt", header = TRUE)
init  <- min(as.POSIXct(GFS$timestamp-GFS$step*3600,origin="1970-01-01"))
title <- sprintf("%s\n%s",
                 "Global Forecast System (GFS) Ensemble Forecast for Innsbruck, Airport",
                 sprintf("Forecast initialized %s",strftime(init,"%Y-%m-%d %H:%M UTC")))

# observations
load("Data/STAGEobs_tawes_11121.rda")
# "2018-03-14 00:00:00" in line 321 (first entry for temperature)
# "2018-03-13 06:00:00" in line 317 (first entry for rain -> aggregated to 24h sums)
# "2018-03-23 00:00:00" in line 357
obs <- obs[318:357,]

getZoo <- function( x, variable ) {
  x <- subset( x, varname == variable )
  if ( nrow(x) == 0 ) stop("Ups, variable seems not to exist at all!")
  # Else create zoo
  x <- zoo( subset(x,select=-c(varname,timestamp,step)),
            as.POSIXct(x$timestamp,origin="1970-01-01") )
  x
}
GFS_t2m  <- getZoo( GFS, "tmp2m" )
# temperature bias: model simulates temperature for height 1675 (~1070 m higher than true height)
# => add 10.7 degrees to account for bias (approx. 1 degree / 100 m)
GFS_t2m <- GFS_t2m + 10.7
GFS_t2m$obs <- obs[,"obs$tl"]
# first value of rain is 18 hours later than temperature 
#(both start at 6:00 but rain is cumulated over 24 hours)
# -> drop first 3 values of temperature
GFS_t2m <- GFS_t2m[-c(1:3),]

GFS_rain <- getZoo( GFS, "apcpsfc" )
GFS_rain$obs <- obs[,"rr6"]
# precipitaion sums over 24 hours (00:00 UTC - 00:00 UTC +1day)
GFS_rain24 <- GFS_rain[c((1:10)*4),]
for(i in 1:NROW(GFS_rain24)){
  GFS_rain24[i,] <- colSums(GFS_rain[c((4*i-3):(4*i)),])
}


# Two POSIXct vectors for the axis
main  <- seq(min(as.POSIXct(as.Date(index(GFS_t2m)))),max(index(GFS_t2m)),by=86400)
minor <- seq(min(index(GFS_t2m)),max(index(GFS_t2m)),by=3*3600)

# GFS_t2m_mean <- rowMeans(GFS_t2m)
GFS_t2m_mean <- GFS_t2m
GFS_t2m_mean[,1] <- rowMeans(GFS_t2m[,-NCOL(GFS_t2m)])
GFS_t2m_mean <- GFS_t2m_mean[,1]

# GFS_rain_mean <- rowMeans(GFS_rain)
GFS_rain24_mean <- GFS_rain24
GFS_rain24_mean[,1] <- rowMeans(GFS_rain24[,-NCOL(GFS_rain24)])
GFS_rain24_mean <- GFS_rain24_mean[,1]
@

<<t2m, echo=FALSE, eval=FALSE>>=
par(mar=c(0.4,0,0.2,0), oma=c(6,3.2,5,4))
layout( matrix(1:2,ncol=1) )
plot(GFS_t2m[,1], screen=1, xaxs="i", xaxt="n", ylim = range(GFS_t2m)*1.05, col = "slategray" )
abline(v = main, lty = 2 )
mtext(side = 3, line = 1, cex = 1.2, font = 2, title )
mtext(side = 2, line = 2.3, cex = 1, font = 1, text = "Temperature [°C]" )
@

<<rain24, echo=FALSE, eval=FALSE>>=
plot(GFS_rain24[,1], screen=1, xaxs="i", xaxt="n", yaxs="i", ylim=range(GFS_rain24)*c(0,1.05), col = "slategray" )
abline(v = main, lty = 2 )
mtext(side = 2, line = 2.3, cex = 1, font = 1, text = "Rain [mm/6h]" )
axis(side = 1, at = main + 42300,  strftime(main,"%b %d"),
      line = 0, col.ticks=NA, col.axis="gray30", col = NA )
@

\begin{frame}[fragile]
\frametitle{Weather forecasting}

\vspace{-0.6cm}
\setkeys{Gin}{width=0.95\linewidth}
\begin{center}
\only<1>{%
<<gfs1, fig=TRUE, echo=FALSE, width=9>>=
<<t2m>>
<<rain24>>
@
}%
\only<2>{%
<<gfs2, fig=TRUE, echo=FALSE, width=9>>=
<<t2m>>
lines(GFS_t2m[,"obs"], col = 2, lwd = 2)
<<rain24>>
lines(GFS_rain24[,"obs"], col = 2, lwd = 2)
@
}%
\only<3>{%
<<gfs3, fig=TRUE, echo=FALSE, width=9>>=
<<t2m>>
lines(GFS_t2m[,2], col = "slategray")
lines(GFS_t2m[,"obs"], col = 2, lwd = 2)
<<rain24>>
lines(GFS_rain24[,2], col = "slategray")
lines(GFS_rain24[,"obs"], col = 2, lwd = 2)
@
}%
\only<4>{%
<<gfs4, fig=TRUE, echo=FALSE, width=9>>=
<<t2m>>
for(j in 2:3) lines(GFS_t2m[,j], col = "slategray")
lines(GFS_t2m[,"obs"], col = 2, lwd = 2)
<<rain24>>
for(j in 2:3) lines(GFS_rain24[,j], col = "slategray")
lines(GFS_rain24[,"obs"], col = 2, lwd = 2)
@
}%
\only<5>{%
<<gfs5, fig=TRUE, echo=FALSE, width=9>>=
<<t2m>>
for(j in 2:(NCOL(GFS_t2m) - 1)) lines(GFS_t2m[,j], col = "slategray")
lines(GFS_t2m[,"obs"], col = 2, lwd = 2)
<<rain24>>
for(j in 2:(NCOL(GFS_rain24) - 1)) lines(GFS_rain24[,j], col = "slategray")
lines(GFS_rain24[,"obs"], col = 2, lwd = 2)
@
}%
\end{center}

\end{frame}


\subsection{Precipitation forecasting}

\begin{frame}[fragile]
\frametitle{Precipitation forecasting}

\textbf{Goal:} Predict daily precipitation amount in complex terrain.

\bigskip
\pause

\textbf{Observation data:} National Hydrographical Service.
\begin{itemize}
\item Daily 24h precipitation sums from July over 28 years (1985--2012).
\item 95 observation stations in Tyrol, Austria.
\end{itemize}

\bigskip
\pause

\textbf{NWP:} Global Ensemble Forecast System.
\begin{itemize}
\item Model outputs: Precipitation, temperature, air pressure, 
  convective available potential energy, downwards short wave radiation flux, \dots
\item 80 covariates based on ensemble min/max/mean/standard deviation.
\end{itemize}

\bigskip
\pause

\textbf{Distribution assumption:} Power-transformed Gaussian, censored at 0.
\[ (\text{precipitation})^\frac{1}{1.6} \sim \textit{c}\mathcal{N}(\mu,\sigma^2) \]

\end{frame}


%% \begin{frame}
%% \frametitle{Precipitation forecasting}
%% 
%% \textbf{Base variables:}
%% \begin{itemize}
%% \item Total precipitation.
%% \item Convective available potential energy.
%% \item Downwards short wave radiation flux (``sunshine'').
%% \item Mean sea level pressure.
%% \item Preciptable water.
%% \item 2m maximum temperature.
%% \item Total column-integrated condensate.
%% \item Temperature.
%% \item Temperature differences in altitude.
%% \end{itemize}
%% 
%% \medskip
%% 
%% \textbf{Variations:} 80 covariates based on ensemble min/max/mean/standard deviation.
%% 
%% \end{frame}


<<pred_axams, eval=TRUE, echo=FALSE, results=hide>>=
if(file.exists("Data/Axams_pred.rda") & file.exists("Data/Axams_testdata.rda")){
  load("Data/Axams_pred.rda")
  load("Data/Axams_testdata.rda")
} else {
  #####
  # load observations and covariates 
  data("RainAxams")
  
  # tree and forest formula
  {
    dt.formula <- df.formula <- 
      robs ~ tppow_mean + tppow_sprd + tppow_min + tppow_max + 
      tppow_mean0612 + tppow_mean1218 + tppow_mean1824 + tppow_mean2430 + 
      tppow_sprd0612 + tppow_sprd1218 + tppow_sprd1824 + tppow_sprd2430 + 
      capepow_mean + capepow_sprd + capepow_min + capepow_max + 
      capepow_mean0612 + capepow_mean1218 + capepow_mean1224 + capepow_mean1230 +
      capepow_sprd0612 + capepow_sprd1218 + capepow_sprd1224 + capepow_sprd1230 +
      dswrf_mean_mean + dswrf_mean_max +  
      dswrf_sprd_mean + dswrf_sprd_max + 
      msl_mean_mean + msl_mean_min + msl_mean_max + 
      msl_sprd_mean + msl_sprd_min + msl_sprd_max +
      pwat_mean_mean + pwat_mean_min + pwat_mean_max + 
      pwat_sprd_mean + pwat_sprd_min + pwat_sprd_max +
      tmax_mean_mean + tmax_mean_min + tmax_mean_max +
      tmax_sprd_mean + tmax_sprd_min + tmax_sprd_max +
      tcolc_mean_mean + tcolc_mean_min + tcolc_mean_max +
      tcolc_sprd_mean + tcolc_sprd_min + tcolc_sprd_max +
      t500_mean_mean + t500_mean_min + t500_mean_max +
      t700_mean_mean + t700_mean_min + t700_mean_max +
      t850_mean_mean + t850_mean_min + t850_mean_max +
      t500_sprd_mean + t500_sprd_min + t500_sprd_max +
      t700_sprd_mean + t700_sprd_min + t700_sprd_max +
      t850_sprd_mean + t850_sprd_min + t850_sprd_max +
      tdiff500850_mean + tdiff500850_min + tdiff500850_max +
      tdiff700850_mean + tdiff700850_min + tdiff700850_max +
      tdiff500700_mean + tdiff500700_min + tdiff500700_max +
      msl_diff
    
    
  }
  
  
  # learning data: 24 years (1985 - 2008, both inlcuded)
  # testing data: 4 successive years (2009, 2010, 2011, 2012)
  learndata <- RainAxams[RainAxams$year < 2009,]
  testdata <- RainAxams[RainAxams$year %in% c(2009, 2010, 2011, 2012),]
  save(file = "Data/Axams_testdata.rda", testdata)
  
  
  
  ##############################################################
  # fitting the models
  set.seed(7)
  
  df <- distforest(df.formula, data = learndata, family = dist_list_cens_normal, 
                   ntree = 100, censtype = "left", censpoint = 0,
                   control = disttree_control(teststat = "quad", testtype = "Univ",
                                              type.tree = "ctree",
                                              intersplit = TRUE,
                                              mincriterion = 0, minsplit = 50,
                                              minbucket = 20), mtry = 27)
  
  
  
  #### prepare data for plot of estimated density functions
  # predictions for one day (in each of the four years) 
  # (19th of July 2011 is missing)
  pday <- 24  # 2 (hohe Beobachtung zu niedrig geschaetzt), 4, 15, evtl. auch 7, 8, 23 (eine 0-Beobachtung und 2 sehr aehnliche), 
  
  pdays <- if(pday<19) c(pday, pday + 31, pday + 62, pday + 92) else c(pday, pday + 31, pday + 61, pday + 92)
  pdf <- predict(df, newdata = testdata[pdays,], type = "parameter")
  pdf$pdays <- pdays
  save(file = "Data/Axams_pred.rda", pdf)
}

pdays <- pdf$pdays
pday <- pdays[1]
df_mu <- pdf$mu
df_sigma <- pdf$sigma

# plot predicted distributions together with observations
set.seed(7)
x <- c(0.01, sort(runif(500,0.01,8)))
y1 <- crch::dcnorm(x, mean = df_mu[1], sd = df_sigma[1], left = 0)
y2 <- crch::dcnorm(x, mean = df_mu[2], sd = df_sigma[2], left = 0)
y3 <- crch::dcnorm(x, mean = df_mu[3], sd = df_sigma[3], left = 0)
y4 <- crch::dcnorm(x, mean = df_mu[4], sd = df_sigma[4], left = 0)

# switch x-axis back to untransformed scale
# x <- x^(1.6)

# point mass (slightly shifted)
pm1 <- c(0.05, crch::dcnorm(-1, mean = df_mu[1], sd = df_sigma[1], left = 0))     #  0.15
pm2 <- c(0.01, crch::dcnorm(-1, mean = df_mu[2], sd = df_sigma[2], left = 0))     #  0.05
pm3 <- c(-0.03, crch::dcnorm(-1, mean = df_mu[3], sd = df_sigma[3], left = 0))    # -0.05
pm4 <- c(-0.07, crch::dcnorm(-1, mean = df_mu[4], sd = df_sigma[4], left = 0))    # -0.15

# predictions
pred1 <- c(testdata[pdays,"robs"][1], # ^(1.6), 
           crch::dcnorm(testdata[pdays,"robs"][1], mean = df_mu[1], sd = df_sigma[1], left = 0))
pred2 <- c(testdata[pdays,"robs"][2], # ^(1.6), 
           crch::dcnorm(testdata[pdays,"robs"][2], mean = df_mu[2], sd = df_sigma[2], left = 0))
pred3 <- c(testdata[pdays,"robs"][3], # ^(1.6), 
           crch::dcnorm(testdata[pdays,"robs"][3], mean = df_mu[3], sd = df_sigma[3], left = 0))
pred4 <- c(testdata[pdays,"robs"][4], # ^(1.6), 
           crch::dcnorm(testdata[pdays,"robs"][4], mean = df_mu[4], sd = df_sigma[4], left = 0))

#legendheight
lh1 <- crch::dcnorm(0.01, mean = df_mu[1], sd = df_sigma[1], left = 0)
lh2 <- crch::dcnorm(0.01, mean = df_mu[2], sd = df_sigma[2], left = 0)
lh3 <- crch::dcnorm(0.01, mean = df_mu[3], sd = df_sigma[3], left = 0)
lh4 <- crch::dcnorm(0.01, mean = df_mu[4], sd = df_sigma[4], left = 0)
@

\begin{frame}[fragile]
\frametitle{Precipitation forecasting}

\textbf{Application for one station:} Axams.
\begin{itemize}
\item Learn forest model on data from 24 years (1985--2008).
\item Evaluate on 4 years (2009--2012). Here: July \Sexpr{24}.
\end{itemize}

\vspace*{-0.2cm}
\begin{center}
\setkeys{Gin}{width=0.58\textwidth}
<<plot_pred_axams_24July, fig=TRUE, echo=FALSE, eval=TRUE, height=5, width=7>>=
par(mar = c(5.1, 4.1, 1.1, 1.1))
plot(x = x, y = y1, type = "l", col = 2, ylab = "Density", 
     # xlab = expression(Total~precipitation~"["~mm~"/"~"24h"~"]"),
     xlab = expression(Total~precipitation~"["~mm^(1/1.6)~"/"~"24h"~"]"),
     ylim = c(0,max(y1, y2, y3, y4, pm1, pm2, pm3, pm4) + 0.01),
     xlim = c(-1.5,8))     #  xlim = c(-2,28))

lines(x = x, y = y2, type = "l", col = 4)
lines(x = x, y = y3, type = "l", col = 3)
lines(x = x, y = y4, type = "l", col = 6)
legend('topright', c("Predicted distribution", "Point mass at censoring point", "Observation"),
       bty = "n", col = "black", lty = c(1, NA, NA), pch = c(NA, 19, 4), cex = 0.8)

# plot point mass
lines(x = c(pm1[1], pm1[1]), y = c(pm1[2], 0), col = 2, type = "l", lwd = 1)
lines(x = c(pm2[1], pm2[1]), y = c(pm2[2], 0), col = 4, type = "l", lwd = 1)
lines(x = c(pm3[1], pm3[1]), y = c(pm3[2], 0), col = 3, type = "l", lwd = 1)
lines(x = c(pm4[1], pm4[1]), y = c(pm4[2], 0), col = 6, type = "l", lwd = 1)

points(x = pm1[1], y = pm1[2], col = 2, pch = 19)
points(x = pm2[1], y = pm2[2], col = 4, pch = 19)
points(x = pm3[1], y = pm3[2], col = 3, pch = 19)
points(x = pm4[1], y = pm4[2], col = 6, pch = 19)


# plot predictions
points(x = pred1[1], y = pred1[2], col = 2, pch = 4, cex = 1.4)
points(x = pred2[1], y = pred2[2], col = 4, pch = 4, cex = 1.4)
points(x = pred3[1], y = pred3[2], col = 3, pch = 4, cex = 1.4)
points(x = pred4[1], y = pred4[2], col = 6, pch = 4, cex = 1.4)

lines(x = c(pred1[1], pred1[1]), y = c(pred1[2], 0), col = "darkgray", type = "l", lty = 2)
lines(x = c(pred2[1], pred2[1]), y = c(pred2[2], 0), col = "darkgray", type = "l", lty = 2)
lines(x = c(pred3[1], pred3[1]), y = c(pred3[2], 0), col = "darkgray", type = "l", lty = 2)
lines(x = c(pred4[1], pred4[1]), y = c(pred4[2], 0), col = "darkgray", type = "l", lty = 2)

# add labels
text(x = -0.8, y = lh1, labels = "2009", col = 2, cex = 0.8)         # -1.7 
text(x = -0.8, y = lh2, labels = "2010", col = 4, cex = 0.8)        # -1.7
text(x = -0.8, y = lh3, labels = "2011", col = 3, cex = 0.8)   # -1.7
text(x = -0.8, y = lh4, labels = "2012", col = 6, cex = 0.8)      # -1.7
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Precipitation forecasting}

\textbf{Application for one station:} Axams.
\begin{itemize}
\item Learn forest model on data from 24 years.
\item Evaluate on 4 years.
\item 10 times 7-fold cross validation.
\end{itemize}

\bigskip

\textbf{Benchmark:} Against other heteroscedastic censored Gaussian models.
\begin{itemize}
\item \emph{Ensemble MOS:} Linear predictors using only total precipitation.
\item \emph{Prespecified GAMLSS:} Variable selection based on expert knowledge.
\item \emph{Boosted GAMLSS:} Automatic variable selection.
\end{itemize}

\bigskip

\textbf{Evaluation:} Continuous ranked probability skill score.

%% \vspace{0.1cm}
%% \begin{table}[t!]
%% \footnotesize
%% 
%% \hskip-0.4cm\begin{tabular}{ l l l }
%% \hline
%% Model & Type & Variable Selection \\
%% \hline
%% \vspace{-0.15cm}
%% \textbf{Distributional forest} & recursive    & automatic \\ 
%%                                & partitioning &           \\ 
%% \vspace{-0.15cm}
%% \textbf{Prespecified GAMLSS}   & spline  & based on expert \\
%%                                & in each & knowledge      \\
%% \vspace{-0.15cm}
%% \textbf{Boosted GAMLSS}        & spline  & automatic  \\
%%                                & in each &            \\
%% \vspace{-0.15cm}
%% \textbf{EMOS}                  & linear & total precipitation mean \\
%%                                &        & and standard deviation   \\
%% \hline
%% \end{tabular}
%% \end{table}

\end{frame}




<<echo=FALSE, results=hide>>=
#### cross validation rain
if(file.exists("Data/crps_cross.rda")){
  load("Data/crps_cross.rda")
} else {
  
  nrep_cross <- 10
  seed <- 7
  
  res_cross <- mclapply(1:nrep_cross,
                        function(i){
                          
                          set.seed(seed*i)
                          
                          # randomly split data in 7 parts each including 4 years
                          years <- 1985:2012
                          testyears <- list()
                          for(j in 1:7){
                            testyears[[j]] <- sample(years, 4, replace = FALSE)
                            years <- years[!(years %in% testyears[[j]])]
                          }
                          
                          #crps <- matrix(nrow = 7, ncol = 7)
                          reslist <- list()
                          for(k in 1:7){
                            test <- testyears[[k]]
                            train <- c(1985:2012)[!c(1985:2012) %in% test]
                            
                            res <- evalmodels(station = "Axams",
                                              train = train,
                                              test = test,
                                              gamboost_cvr = TRUE)
                            
                            #crps[k,] <- res$crps
                            reslist[[k]] <- res
                          }
                          
                          #colnames(crps) <- names(res$crps)
                          return(reslist)
                        },
                        mc.cores = detectCores() - 1
  )
  
  # extract CRPS
  crps_cross <- matrix(nrow = nrep_cross, ncol = 7)
  # loop over all repetitions
  for(i in 1:length(res_cross)){
    #loop over all 7 folds (for 7 methods)
    crps_cross_int <- matrix(nrow = length(res_cross[[1]]), ncol = 7)
    for(j in 1:length(res_cross[[1]])){
      crps_cross_int[j,] <- res_cross[[i]][[j]]$crps
    }
    crps_cross[i,] <- colMeans(crps_cross_int, na.rm = TRUE)
  }
  colnames(crps_cross) <- names(res_cross[[1]][[1]]$crps) 
  
  save(crps_cross, file = "Data/crps_cross.rda")
}
@




\begin{frame}[fragile]
\frametitle{Precipitation forecasting}
\begin{center}
\vspace*{-0.6cm}
\setkeys{Gin}{width=0.7\textwidth}
<<rain_cross_axams_crps_skills_score, fig=TRUE, echo=FALSE, height=5.6, width=6.8>>=
#par(mar = c(2.5,2,1,2))
boxplot(1 - crps_cross[,c(2,3,4)] / crps_cross[,6], ylim = c(-0.005, 0.065),
        names = c("Distributional forest", "Prespecified GAMLSS", "Boosted GAMLSS"),
        main = "Cross validation (with reference model EMOS)",
        cex.main=1.4,
        cex.lab=1.2,
        ylab = "CRPS skill score", col = "lightgray") 
abline(h = 0, col = pal["EMOS"], lwd = 2)
@
\end{center}
\end{frame}





\begin{frame}[fragile]
\frametitle{Precipitation forecasting}
\vspace{0.2cm}
\textbf{Application for all 95 stations:}
\begin{itemize}
\item Learn forest model on data from 24 years (1985--2008).
\item Evaluate on 4 years (2009--2012).
\item Benchmark against other heteroscedastic censored Gaussian models.
\end{itemize}

\end{frame}


<<echo = FALSE>>=
#### prediction over all stations 24 - 4
if(file.exists("Data/crps_24to4_all.rda")){
  load("Data/crps_24to4_all.rda")
} else {
  
  data("StationsTyrol")
  stations <- StationsTyrol$name
  test <- 2009:2012
  train <- 1985:2008
  
  
  res_24to4_all <- mclapply(1:length(stations),
                            function(i){
                              
                              set.seed(7)
                              
                              res <- evalmodels(station = stations[i],
                                                train = train,
                                                test = test,
                                                gamboost_cvr = TRUE)
                              
                              return(res)
                            },
                            mc.cores = detectCores() - 1
  )
  
  # extract crps
  crps_24to4_all <- matrix(nrow = length(stations), ncol = 7)
  # loop over all stations
  for(i in 1:length(stations)){
    crps_24to4_all[i,] <- res_24to4_all[[i]]$crps
  }
  
  colnames(crps_24to4_all) <- names(res_24to4_all[[1]]$crps)
  rownames(crps_24to4_all) <- stations
  
  save(crps_24to4_all, file = "Data/crps_24to4_all.rda")
}


# skill score
s <- 1 - crps_24to4_all[, 2:4]/crps_24to4_all[,6] 
colnames(s) <- c("Distributional forest", "Prespecified GAMLSS", "Boosted GAMLSS")


## prepare data for map which shows where distforest performed better than gamlss or gamboostLSS based on the crps

crps_map <- crps_24to4_all[,c("distforest", "gamlss", "gamboostLSS", "emos_log")]  

# best method
bst <- apply(crps_map, 1, which.min)

# distance of forest to best other method
dst <- crps_map[,1] - crps_map[cbind(1:nrow(crps_map), apply(crps_map[, -1], 1, which.min) + 1)]

# breaks/groups
brk <- c(-0.1, -0.05, -0.005, 0.005, 0.05, 0.1)
#brk <- c(-0.1, -0.05, -0.01, 0.01, 0.05, 0.1)
grp <- cut(dst, breaks = brk)

# HCL colors (relatively flashy, essentially CARTO Tropic)
clr <- colorspace::diverging_hcl(5, h = c(130, 320), c = 70, l = c(50, 90), power = 1.3)


library("raster") # dem (digital elevation model)
library("sp")     # gadm www.gadm.org/country

data("StationsTyrol", package = "RainTyrol")
data("MapTyrol", package = "RainTyrol")
# data(MapTyrol_border, package = "RainTyrol")
# Create SpatialPointsDataFrame from station list
sp <- SpatialPointsDataFrame(subset(StationsTyrol,
                                    select=c(lon,lat)),
                             data = subset(StationsTyrol,
                                           select = -c(lon,lat)),
                             proj4string = crs(MapTyrol$RasterLayer))
@


\begin{frame}[fragile]
\frametitle{Precipitation forecasting}
\begin{center}
\vspace*{-0.5cm}

\setkeys{Gin}{width=0.8\textwidth}
<<map, fig=TRUE, echo=FALSE, width=10, height=6.5>>=

  ## plot map of Tyrol with all 95 observations
  layout(cbind(1, 2), width = c(9, 1))
  par(mar = c(5,4,4,0.1))
  raster::image(MapTyrol$RasterLayer, col = rev(gray.colors(100)),
                main="Stations in Tyrol", ylab = "Latitude", xlab = "Longitude", 
                xlim = c(9.8,13.2), 
                ylim = c(46.6, 47.87))
  plot(MapTyrol$SpatialPolygons, add = TRUE)
  points(sp[70,], pch = 19, col = "black", cex = 1.85)
  points(sp, pch = c(21, 24, 25, 22)[bst], bg = clr[grp], col = "black", las = 1, cex = 1.5)
  legend(x = 9.8, y = 47.815, pch = c(21, 24, 25, 22), legend = c("Distributional forest", "Prespecified GAMLSS", "Boosted GAMLSS", "EMOS"), cex = 1, bty = "n")
  text(x = 10.3, y = 47.82, labels = "Models with lowest CRPS")
  mtext("CRPS\ndifference", side=4, las = TRUE, at = c(x = 13.5, y = 47.76), line = 0.3)
  par(mar = c(0.5,0.2,0.5,2.3))
  ## legend
  plot(0, 0, type = "n", axes = FALSE, xlab = "", ylab = "",
       xlim = c(0, 1), ylim = c(-0.2, 0.2), xaxs = "i", yaxs = "i")
  rect(0, brk[-6], 0.5, brk[-1], col = rev(clr))
  axis(4, at = brk, las = 1, mgp=c(0,-0.5,-1))


@
\end{center}
\end{frame}


\subsection{Wind forecasting}

\begin{frame}[fragile]
\frametitle{Wind forecasting}

\textbf{Goal:} Nowcasting (1--3 hours ahead) of wind direction at Innsbruck Airport.

\bigskip
\pause

\textbf{Challenges:}
\begin{itemize}
  \item Circular response in $[0^{\circ}, 360^{\circ})$ with $0^{\circ} = 360^{\circ}$.
  \item Possibly abrupt changes due to geographical position.
  \item NWP outputs are less useful due to short lead time.
\end{itemize}

\bigskip
\pause

\textbf{Inputs:} Observation data only (41,979 data points).
\begin{itemize}
  \item 4 stations at Innsbruck Airport, 6 nearby weather stations. 
  \item Base variables: Wind direction, wind (gust) speed, temperature, (reduced) air pressure, relative humidity.
  \item 260 covariates based on means/minima/maxima, temporal changes, spatial differences towards the airport.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Wind forecasting}

\vspace*{-0.4cm}

\setkeys{Gin}{width=0.75\linewidth}
\begin{center}
\includegraphics{ibk_airport.png}
\end{center}

\end{frame}


\begin{frame}[fragile]
\frametitle{Wind forecasting}

\vspace*{-0.3cm}

\begin{minipage}{0.5\textwidth}
\textbf{Distribution assumption:} Von Mises.
\begin{itemize}
\item Circular normal distribution.
\item Location parameter $\mu \in [0, 2 \pi)$.
\item Concentration parameter $\kappa > 0$.
\end{itemize}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\only<1>{\includegraphics[width=\linewidth]{density_linear.pdf}}%
\only<2>{\includegraphics[width=\linewidth]{density_circular.pdf}}%
\end{minipage}

\bigskip
\medskip

\textbf{Log-likelihood:} $y \in [0, 2 \pi)$ and parameter vector $\theta = (\mu, \kappa)$.
$$
\ell(\theta; y) = \log \left\{ \frac{1}{2 \pi I_0(\kappa)}~e^{ \kappa \cos(y - \mu)} \right\}
$$
where $I_0(\kappa)$ is the modified Bessel function of the first kind and order $0$.

\end{frame}



\begin{frame}[fragile]
\frametitle{Wind forecasting}

\vspace{-0.7cm}

\setkeys{Gin}{width=1\linewidth}
\begin{center}
\includegraphics{circtree_ibk.pdf}
\end{center}

\end{frame}

\begin{frame}[fragile]
\frametitle{Wind forecasting}

\textbf{Benchmark:} Against other naive and circular models.
\begin{itemize}
\item Climatology: Without covariates.
\item Persistency: Based on current wind direction.
\item Circular GLM: Based on current wind speed and wind vector $(u, v)$.
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Wind forecasting}

%\includegraphics{circforest_crpsraw_ibk_lag1.pdf}
%\includegraphics{circforest_crpsraw_ibk_lag3.pdf}

\textbf{Evaluation:} CRPS skill score for \only<1>{1}\only<2>{3}-hourly predictions (5-fold cross validation).
\begin{center}
\setkeys{Gin}{width=0.88\linewidth}
\only<1>{\includegraphics{circforest_crpsskill_ibk_lag1.pdf}}%
\only<2>{\includegraphics{circforest_crpsskill_ibk_lag3.pdf}}
\end{center}

\end{frame}


\subsection{Transformation models}

\begin{frame}
\frametitle{Transformation models}

\textbf{Alternative:} When no obvious classic distribution assumption is available.

\medskip

\textbf{Advantages:}
\begin{itemize}
\item Does not require specification of distribution family.
\item More flexible framework.
\end{itemize}

\medskip

\textbf{Distribution function:}
\[
F(y; \theta) = \Phi(\bold{a}_{Bs,d}(y)^\top \theta) 
\]
\begin{itemize} 
\item $\bold{a}_{Bs,d}(y)^\top \theta$ is a smooth, monotone Bernstein polynomial of degree $d$.
\item $d=1$ corresponds to $\mathcal{N}(\mu,\sigma^2)$.
\item $d=5$ is surprisingly flexible.
\end{itemize}

\medskip

\textbf{Example:} Body Mass Index explained by lifestyle factors (Switzerland).

\end{frame}

\begin{frame}
\frametitle{Transformation models}

\vspace*{0.2cm}
\includegraphics[width=0.84\textwidth]{cmpx-tree.pdf}

\end{frame}


\subsection{Software}

\begin{frame}
\frametitle{Software}
%\vspace{0.4cm}
\textbf{Software:} \emph{disttree} and \emph{circtree} 
available on R-Forge at\\

\medskip

\small{\url{https://R-Forge.R-project.org/projects/partykit/}}\\ 
%and\\
%\url{https://R-Forge.R-project.org/projects/uibk-rprog-2018/}}\\

\bigskip
\medskip

\textbf{Main functions:}

\medskip

\begin{tabular}{ll}
\code{distfit}    & Distributional fits (ML, \code{gamlss.family}/custom \code{list}).\\
& No covariates. \\
\code{disttree}   & Distributional trees (\code{ctree}/\code{mob} + \code{distfit}).\\
& Covariates as partitioning variables. \\
\code{distforest} & Distributional forests (ensemble of \code{disttree}s).\\
& Covariates as partitioning variables.
\end{tabular}

\bigskip
\medskip

\textbf{Correspondingly:} \code{circtree}, \code{circforest}

\end{frame}





\subsection{References}


\begin{frame}
\frametitle{References}

\vspace{-0.2cm}

\footnotesize
Schlosser L, Hothorn T, Stauffer R, Zeileis A (2019).
\dquote{Distributional Regression Forests for Probabilistic Precipitation Forecasting in Complex Terrain.}
\emph{The Annals of Applied Statistics}, \textbf{13}(3), 1564--1589.
\doi{10.1214/19-AOAS1247}
 
\medskip

Schlosser L, Lang MN, Hothorn T, Mayr GJ, Stauffer R, Zeileis A (2019).
\dquote{Distributional Trees for Circular Data.}
\emph{Proceedings of the 34th International Workshop on Statistical Modelling}, 
\textbf{1}, 226--231.
\url{https://eeecon.uibk.ac.at/~zeileis/papers/Schlosser+Lang+Hothorn-2019.pdf}

\medskip

Hothorn T, Zeileis A (2017).
  \dquote{Transformation Forests.}
  \emph{arXiv 1701.02110}, arXiv.org E-Print Archive.
  \url{http://arxiv.org/abs/1701.02110}
  
\bigskip
\bigskip
  
Hothorn T, Hornik K, Zeileis A (2006).
 \dquote{Unbiased Recursive Partitioning: A Conditional Inference Framework.}
 \emph{Journal of Computational and Graphical Statistics},
 \textbf{15}(3), 651--674.
 \doi{10.1198/106186006X133933}
 
\medskip

Zeileis A, Hothorn T, Hornik K (2008).
 \dquote{Model-Based Recursive Partitioning.}
  \emph{Journal of Computational and Graphical Statistics},
  \textbf{17}(2), 492--514.
  \doi{10.1198/106186008X319331}

\medskip

Hothorn T, Zeileis A (2015).
 \dquote{{partykit}: A Modular Toolkit for Recursive Partytioning in \textsf{R}.}
 \emph{Journal of Machine Learning Research},
 \textbf{16}, 3905--3909.
 \url{http://www.jmlr.org/papers/v16/hothorn15a}



%% \medskip
%% 
%% Stasinopoulos DM, Rigby RA (2007).
%%   \dquote{Generalized Additive Models for Location Scale and Shape (GAMLSS) in \textsf{R}.}
%%   \emph{Journal of Statistical Software}, 
%%   \textbf{23}(7), 1--46.
%%   \doi{10.18637/jss.v023.i07}
%%   
%% \medskip
%% 
%% Breiman L (2001).
%%   \dquote{Random {Forests}}
%%   \emph{Machine Learning}, 
%%   \textbf{45}(1), 5--32.
%%   \doi{10.1023/A:1010933404324}

\end{frame}

\end{document}
