% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crps.distribution.R
\name{crps.distribution}
\alias{crps.distribution}
\alias{crps.Beta}
\alias{crps.Bernoulli}
\alias{crps.Binomial}
\alias{crps.Erlang}
\alias{crps.Exponential}
\alias{crps.Gamma}
\alias{crps.GEV}
\alias{crps.Geometric}
\alias{crps.Gumbel}
\alias{crps.HyperGeometric}
\alias{crps.Logistic}
\alias{crps.LogNormal}
\alias{crps.NegativeBinomial}
\alias{crps.Normal}
\alias{crps.Poisson}
\alias{crps.StudentsT}
\alias{crps.Uniform}
\alias{crps.GAMLSS}
\title{Methods for Evaluating the CRPS of Probability Distributions}
\usage{
crps.distribution(
  y,
  x,
  drop = TRUE,
  elementwise = NULL,
  gridsize = 500,
  batchsize = 10000,
  applyfun = NULL,
  cores = NULL,
  ...
)

crps.Beta(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Bernoulli(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Binomial(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Erlang(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Exponential(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Gamma(y, x, drop = TRUE, elementwise = NULL, ...)

crps.GEV(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Geometric(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Gumbel(y, x, drop = TRUE, elementwise = NULL, ...)

crps.HyperGeometric(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Logistic(y, x, drop = TRUE, elementwise = NULL, ...)

crps.LogNormal(y, x, drop = TRUE, elementwise = NULL, ...)

crps.NegativeBinomial(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Normal(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Poisson(y, x, drop = TRUE, elementwise = NULL, ...)

crps.StudentsT(y, x, drop = TRUE, elementwise = NULL, ...)

crps.Uniform(y, x, drop = TRUE, elementwise = NULL, ...)

crps.GAMLSS(y, x, drop = TRUE, elementwise = NULL, ...)
}
\arguments{
\item{y}{A distribution object, e.g., as created by
\code{\link[distributions3]{Normal}} or \code{\link[distributions3]{Binomial}}.}

\item{x}{A vector of elements whose CRPS should be determined given the
distribution \code{y}.}

\item{drop}{logical. Should the result be simplified to a vector if possible?}

\item{elementwise}{logical. Should each distribution in \code{y} be evaluated
at all elements of \code{x} (\code{elementwise = FALSE}, yielding a matrix)?
Or, if \code{y} and \code{x} have the same length, should the evaluation be
done element by element (\code{elementwise = TRUE}, yielding a vector)? The
default of \code{NULL} means that \code{elementwise = TRUE} is used if the
lengths match and otherwise \code{elementwise = FALSE} is used.}

\item{gridsize}{positive size of the grid used to approximate the CDF for
the numerical calculation of the CRPS.}

\item{batchsize}{maximum batch size. Used to split the input into batches.
Lower values reduce required memory but may increase computation time.}

\item{applyfun}{an optional \code{\link[base]{lapply}}-style function with arguments
\code{function(X, FUN, \dots)}. It is used to compute the CRPS for each element
of \code{y}. The default is to use the basic \code{lapply}
function unless the \code{cores} argument is specified (see below).}

\item{cores}{numeric. If set to an integer the \code{applyfun} is set to
\code{\link[parallel]{mclapply}} with the desired number of \code{cores},
except on Windows where \code{\link[parallel]{parLapply}} with
\code{makeCluster(cores)} is used.}

\item{...}{currently not used.}
}
\value{
In case of a single distribution object, either a numeric
  vector of \code{length(x)} (if \code{drop = TRUE}, default) or a matrix with
  \code{length(x)} columns (if \code{drop = FALSE}). In case of a vectorized distribution
  object, a matrix with \code{length(x)} columns containing all possible combinations.
}
\description{
Methods to the \code{\link[scoringRules]{crps}} generic function from
the \pkg{scoringRules} package for evaluating the (continuous) ranked probability
score (CRPS) of any probability \pkg{distributions3} object.
}
\details{
The (continuous) ranked probability score (CRPS) for (univariate) probability
distributions can be computed based on the the object-oriented infrastructure
provided by the \pkg{distributions3} package. The general \code{crps.distribution}
method does so by using numeric integration based on the \code{cdf} and/or \code{quantile}
methods (for more details see below). Additionally, if dedicated closed-form
CRPS computations are provided by the \pkg{scoringRules} package for the specified
distribution, then these are used because they are both computationally faster
and numerically more precise. For example, the \code{crps} method for \code{Normal}
objects leverages \code{\link[scoringRules]{crps_norm}} rather than relying on
numeric integration.

The general method for any \code{distribution} object uses the following strategy
for numerical CRPS computation. It distinguishes distributions whose
entire support is continuous or whose entire support is discrete, or mixed
discrete-continuous distribution using \code{\link[distributions3]{is_continuous}}
and \code{\link[distributions3]{is_discrete}}, respectively.

For continuous and mixed distributions, an equidistant grid of \code{gridsize + 5}
probabilities is drawn for which the corresponding \code{quantile}s for each
distribution \code{y} are calculated (including the observation \code{x}). The
calculation of the CRPS then uses a trapezodial approximation for the
numeric integration.  For discrete distributions \code{gridsize} equidistant quantiles are
drawn and the corresponding probabilities from the \code{cdf} are calculated for
each distribution \code{y} (including the observation \code{x}) and the CRPS calculated using
numeric integration.  If the \code{gridsize} is not sufficient to cover
the required range, the method falls back to the procedure used for
continuous distributions to approximate the CRPS.

The numeric approximation requires to set up a matrix of dimension
\code{length(y) * (gridsize + 5)} (or \code{length(y) * (gridsize + 1)}) which may be very
memory intensive if \code{length(y)} and/or \code{gridsize} are large. Thus, the data is
split batches of (approximately) equal size, not larger than \code{batchsize}.
Thus, the memory requirement is reduced to \code{batchsize * (gridsize + 5)} in each step.
Hence, a smaller value of \code{batchsize} will reduce memory footprint but will
slightly increase computation time.

The error (deviation between numerical approximation and analytic solution)
has been shown to be in the order of \code{1e-2} for a series of distributions
tested. Accuracy can be increased by increasing \code{gridsize} and will be lower
for a smaller \code{gridsize}.

For parallelization of the numeric computations, a suitable \code{applyfun} can be
provided that carries out the integration for each element of \code{y}. To facilitate
setting up a suitable \code{applyfun} using the basic \pkg{parallel} package, the
argument \code{cores} is provided for convenience. When used, \code{y}
is split into \code{B} equidistant batches; at least \code{B = cores} batches or
a multiple of \code{cores} with a maximum size of \code{batchsize}. On systems running
Windows \code{parlapply} is used, else \code{mclapply}.
}
\examples{
\dontshow{ if(!requireNamespace("scoringRules")) {
  if(interactive() || is.na(Sys.getenv("_R_CHECK_PACKAGE_NAME_", NA))) {
    stop("not all packages required for the example are installed")
  } else q() }
}
set.seed(6020)

## three normal distributions X and observations x
library("distributions3")
X <- Normal(mu = c(0, 1, 2), sigma = c(2, 1, 1))
x <- c(0, 0, 1)

## evaluate crps using infrastructure from scoringRules
library("scoringRules")
crps(X, x)

## using general distribution method (based on numeric integration)
crps.distribution(X, x)

## analogously for Poisson distribution
Y <- Poisson(c(0.5, 1, 2))
crps(Y, x)
crps.distribution(Y, x)

}
