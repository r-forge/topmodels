% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NumericNormal.R
\name{pdf.distribution}
\alias{pdf.distribution}
\alias{quantile.distribution}
\title{Methods for Numerically Approximating PDF and Quantile Functions}
\usage{
\method{pdf}{distribution}(d, x, drop = TRUE, elementwise = NULL, log = FALSE, ...)

\method{quantile}{distribution}(
  x,
  probs,
  drop = TRUE,
  elementwise = NULL,
  lower = -1/sqrt(.Machine$double.eps),
  upper = +1/sqrt(.Machine$double.eps),
  tol = .Machine$double.eps^0.5,
  ...
)
}
\arguments{
\item{d}{An object of class `"distribution"`.}

\item{x}{Either a numeric vector of probabilities to be evaluated (if `pdf()` is called),
or an object of class `"distributions"` (as `d`) when calling the `quantile()` function.}

\item{drop}{Logical. Should the result be simplified to a vector if possible?}

\item{elementwise}{Logical. Should each distribution (in `d`/`x`) be evaluated at all
elements in `x` (when `pdf()` is called) or `probs` (if `quantile()` is called)?
The default `NULL` means that `elementwise = TRUE` is used if the lengths match,
else `elementwise` is set `FALSE`.}

\item{log}{Logical. If `TRUE`, probabilities are given as `log(p)`.}

\item{...}{currently ignored.}

\item{probs}{Numeric vector of probabilities with values in [0,1].}

\item{lower, upper}{numeric. Lower and upper end points for the interval to
be searched, forwarded to [stats::uniroot()].}

\item{tol}{numeric. Desired accuracy for [stats::uniroot()].}
}
\description{
Methods to the generic \link[distributions3]{pdf} and \link[stats]{quantile} functions from the
\pkg{distributions3} package for numerically approximating the probability density function (PDF)
or the quantile function (inverse CDF) if only the cummulative distribution function (CDF) is given.
}
\examples{
library("distributions3")
library("ggplot2")

## ------------- custom Normal distribution (MyNormal) ----------------

## Constructor function for new 'MyNormal' distribution
MyNormal <- function(mu, sigma) {
    d <- data.frame(mu = mu, sigma = sigma)
    class(d) <- c("MyNormal", "distribution")
    return(d)
}

## Additional S3 methods required
cdf.MyNormal <- getS3method("cdf", class = "Normal")
is_discrete.MyNormal   <- getS3method("is_discrete", class = "Normal")
support.MyNormal       <- getS3method("support", class = "Normal")

## Constructing objects; three normal distributions with
## mean c(1, 2, 3) and standard deviation c(1, 2.5, 5).
## n3: Based on MyNormal where only cdf, id_discrete, and support are defined.
## N3: Analytic solution (distributions3::Normal()) with analytic
##     functions for all distribution functions (pdf, cdf, quantile)
##     as well as for the first four central moments
##     (mean, variance, skewness, kurtosis)
n3 <- MyNormal(mu = 1:3, sigma = c(1, 2.5, 5))
N3 <- Normal(mu = 1:3, sigma = c(1, 2.5, 5))

## Class 'MyNormal' knows the analytic cdf:
cdf(n3, x = 2)
identical(cdf(n3, x = 2), cdf(N3, x = 2))

## Calculating probability at x = 2
pdf(n3, x = 2) ## Numeric approximation
pdf(N3, x = 2) ## Analytic solution
pdf(n3, x = 2) - pdf(N3, x = 2) ## Pairwise differences/precision

## Calculating quantiles
probs <- c(0.0, 0.01, 0.25, 0.5, 0.75, 0.99, 1.0)
quantile(n3, probs = probs) ## Numeric approximation
quantile(N3, probs = probs) ## Analytic solution

probs2 <- seq(0.01, 0.99, by = 0.01)
qn3 <- quantile(n3, probs = probs2) ## Numeric approximation
qN3 <- quantile(N3, probs = probs2) ## Analytic solution
range(qn3 - qN3) ## Range of pairwise differences/precision

## Visual comparison
x <- seq(-3, 5, by = 0.1)

d <- data.frame(x = rep(x, times = 2),
                y = c(pdf(n3[1], x = x), pdf(N3[1], x = x)),
                solution = rep(c("analytic (Normal)", "approximation (MyNormal)"), each = length(x)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = c("tomato", "black")) +
    labs(title = "Density function")

probs <- seq(0.01, 0.99, by = 0.01)
d <- data.frame(x = c(quantile(n3[1], probs = probs), quantile(N3[1], probs = probs)),
                y = rep(probs, times = 2),
                solution = rep(c("analytic (Normal)", "approximation (MyNormal)"), each = length(probs)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = c("tomato", "black")) +
    labs(title = "Quantile function")

## ------------- custom Poisson distribution (MyPoisson) --------------

## Custom constructor function for the 'MyPoisson' distribution
MyPoisson <- function(lambda) {
    d <- data.frame(lambda = lambda)
    class(d) <- c("MyPoisson", "distribution")
    return(d)
}

## Additional S3 methods required
cdf.MyPoisson <- getS3method("cdf", class = "Poisson")
is_discrete.MyPoisson   <- getS3method("is_discrete", class = "Poisson")
support.MyPoisson       <- getS3method("support", class = "Poisson")

## Constructing objects; three normal distributions with
## parameter lambda = c(1, 2.5, 5).
## p3: Based on MyPoisson where only cdf, id_discrete, and support are defined.
## P3: Analytic solution (distributions3::Poisson()) with analytic
##     functions for all distribution functions (pdf, cdf, quantile)
##     as well as for the first four central moments
##     (mean, variance, skewness, kurtosis)
p3 <- MyPoisson(lambda = c(1, 2.5, 5))
P3 <- Poisson(lambda = c(1, 2.5, 5))

## Class 'MyPoisson' knows the analytic cdf:
cdf(p3, x = 2)
identical(cdf(p3, x = 2), cdf(P3, x = 2))

## Calculating probability at x = 2
pdf(p3, x = 2) ## Numeric approximation
pdf(P3, x = 2) ## Analytic solution
pdf(p3, x = 2) - pdf(P3, x = 2) ## Pairwise differences/precision

## Calculating quantiles
probs <- c(0.0, 0.01, 0.25, 0.5, 0.75, 0.99, 1.0)
quantile(p3, probs = probs) ## Numeric approximation
quantile(P3, probs = probs) ## Analytic solution

probs2 <- seq(0.01, 0.99, by = 0.01)
qp3 <- quantile(p3, probs = probs2) ## Numeric approximation
qP3 <- quantile(P3, probs = probs2) ## Analytic solution
range(qp3 - qP3) ## Range of pairwise differences/precision

## Visual comparison
x <- seq(-1, 11, by = 0.1)
d <- data.frame(x = rep(x, times = 2),
                y = c(pdf(p3[2], x = x), pdf(P3[2], x = x)),
                solution = rep(c("analytic (Poisson)", "approximation (MyPoisson)"), each = length(x)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = c("tomato", "black")) +
    labs(title = "Density function")

probs <- seq(0.01, 0.99, by = 0.01)
d <- data.frame(x = c(quantile(p3[2], probs = probs), quantile(P3[2], probs = probs)),
                y = rep(probs, times = 2),
                solution = rep(c("analytic (Poisson)", "approximation (MyPoisson)"), each = length(probs)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = c("tomato", "black")) +
    labs(title = "Quantile function")

}
