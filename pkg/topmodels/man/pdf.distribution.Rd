% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distribution.R
\name{pdf.distribution}
\alias{pdf.distribution}
\alias{quantile.distribution}
\alias{cdf.distribution}
\title{Methods for Numerically Approximating PDF and Quantile Functions}
\usage{
\method{pdf}{distribution}(
  d,
  x,
  drop = TRUE,
  elementwise = NULL,
  log = FALSE,
  applyfun = NULL,
  cores = NULL,
  ...
)

\method{quantile}{distribution}(
  x,
  probs,
  drop = TRUE,
  elementwise = NULL,
  lower = -1/sqrt(.Machine$double.eps),
  upper = +1/sqrt(.Machine$double.eps),
  tol = .Machine$double.eps^0.5,
  maxit = 1000,
  ...
)

\method{cdf}{distribution}(d, x, drop = TRUE, elementwise = NULL, lower.tail = TRUE, ...)
}
\arguments{
\item{d}{An object of class \code{"distribution"}.}

\item{x}{Either a numeric vector of probabilities to be evaluated (if \code{pdf()} is called),
or an object of class \code{"distributions"} (as \code{d}) when calling the \code{quantile()} function.}

\item{drop}{Logical. Should the result be simplified to a vector if possible?}

\item{elementwise}{Logical. Should each distribution (in \code{d}/\code{x}) be evaluated at all
elements in \code{x} (when \code{pdf()} is called) or \code{probs} (if \code{quantile()} is called)?
The default \code{NULL} means that \code{elementwise = TRUE} is used if the lengths match,
else \code{elementwise} is set \code{FALSE}.}

\item{log}{Logical. If \code{TRUE}, probabilities are given as \code{log(p)}.}

\item{applyfun}{an optional \code{\link[base]{lapply}}-style function with arguments
\code{function(X, FUN, \dots)}. It is used to compute the CRPS for each element
of \code{y}. The default is to use the basic \code{lapply}
function unless the \code{cores} argument is specified (see below).}

\item{cores}{numeric. If set to an integer the \code{applyfun} is set to
\code{\link[parallel]{mclapply}} with the desired number of \code{cores},
except on Windows where \code{\link[parallel]{parLapply}} with
\code{makeCluster(cores)} is used.}

\item{...}{currently ignored.}

\item{probs}{Numeric vector of probabilities with values in [0,1].}

\item{lower, upper}{numeric. Lower and upper end points for the interval to
be searched, forwarded to [stats::uniroot()].}

\item{tol}{numeric. Desired accuracy for [stats::uniroot()].}

\item{maxit}{Integer (default \code{1000L}). Maximum number of iterations used when iteratively evaluating
quantiles based on a pdf (discrete distributions only). If \code{maxit} is reached
before the quantile has been found, an error will be thrown.}

\item{lower.tail}{Logical. If \code{TRUE} (default), probabilities are
\eqn{P[X \le x]}{P[X <= x]}, else \eqn{P[X \ge x]}{P[X >= x]}.}
}
\description{
Methods to the generic \link[distributions3]{pdf} and \link[stats]{quantile} functions from the
\pkg{distributions3} package for numerically approximating the probability density function (PDF)
or the quantile function (inverse CDF) if only the cummulative distribution function (CDF) is given.
}
\examples{
library("distributions3")
library("ggplot2")

## ------------- custom Normal distribution (MyNormal) ----------------

## Constructor function for new 'MyNormal' distribution
MyNormal <- function(mu, sigma) {
    d <- data.frame(mu = mu, sigma = sigma)
    class(d) <- c("MyNormal", "distribution")
    return(d)
}

## Additional S3 methods required
cdf.MyNormal <- getS3method("cdf", class = "Normal")
is_discrete.MyNormal   <- getS3method("is_discrete", class = "Normal")
support.MyNormal       <- getS3method("support", class = "Normal")

## Constructing objects; three normal distributions with
## mean c(1, 2, 3) and standard deviation c(1, 2.5, 5).
## n3: Based on MyNormal where only cdf, id_discrete, and support are defined.
## N3: Analytic solution (distributions3::Normal()) with analytic
##     functions for all distribution functions (pdf, cdf, quantile)
##     as well as for the first four central moments
##     (mean, variance, skewness, kurtosis)
n3 <- MyNormal(mu = 1:3, sigma = c(1, 2.5, 5))
N3 <- Normal(mu = 1:3, sigma = c(1, 2.5, 5))

## Class 'MyNormal' knows the analytic cdf:
cdf(n3, x = 2)
identical(cdf(n3, x = 2), cdf(N3, x = 2))

## Calculating probability at x = 2
pdf(n3, x = 2) ## Numeric approximation
pdf(N3, x = 2) ## Analytic solution
pdf(n3, x = 2) - pdf(N3, x = 2) ## Pairwise differences/precision

## Calculating quantiles
probs <- c(0.0, 0.01, 0.25, 0.5, 0.75, 0.99, 1.0)
quantile(n3, probs = probs) ## Numeric approximation
quantile(N3, probs = probs) ## Analytic solution

probs2 <- seq(0.01, 0.99, by = 0.01)
qn3 <- quantile(n3, probs = probs2) ## Numeric approximation
qN3 <- quantile(N3, probs = probs2) ## Analytic solution
range(qn3 - qN3) ## Range of pairwise differences/precision

## Visual comparison
x <- seq(-3, 5, by = 0.1)

d <- data.frame(x = rep(x, times = 2),
                y = c(pdf(n3[1], x = x), pdf(N3[1], x = x)),
                solution = rep(c("approximated MyNormal", "analytic Normal"), each = length(x)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = 1:2) +
    labs(title = "Density function (mean = 1, sigma = 1)")

probs <- seq(0.01, 0.99, by = 0.01)
d <- data.frame(x = c(quantile(n3[1], probs = probs), quantile(N3[1], probs = probs)),
                y = rep(probs, times = 2),
                solution = rep(c("approximated MyNormal", "analytic Normal"), each = length(probs)))
ggplot(data = d) + geom_line(aes(x = x, y = y, col = solution, lty = solution), lwd = 1) +
    scale_color_manual(values = 1:2) +
    labs(title = "Quantile function (mean = 3, sigma = 5)")

## Drawing random numbers
set.seed(6020)
d <- data.frame(x = c(random(n3[3], 500L), random(N3[3], 500L)),
                distribution = rep(c("approximated MyNormal", "analytic Normal"), each = 500L))
ggplot(data = d) + geom_density(aes(x = x, col = distribution)) +
    scale_color_manual(values = 1:2) +
    labs(title = "Density of random numbers (mean = 3, sigma = 5)")

## ------------- custom Poisson distribution (MyPoisson) --------------

## Custom constructor function for the 'MyPoisson' distribution
MyPoisson <- function(lambda) {
    d <- data.frame(lambda = lambda)
    class(d) <- c("MyPoisson", "distribution")
    return(d)
}

## Additional S3 methods required
cdf.MyPoisson <- getS3method("cdf", class = "Poisson")
is_discrete.MyPoisson   <- getS3method("is_discrete", class = "Poisson")
support.MyPoisson       <- getS3method("support", class = "Poisson")

## Constructing objects; three normal distributions with
## parameter lambda = c(1, 2.5, 5).
## p3: Based on MyPoisson where only cdf, id_discrete, and support are defined.
## P3: Analytic solution (distributions3::Poisson()) with analytic
##     functions for all distribution functions (pdf, cdf, quantile)
##     as well as for the first four central moments
##     (mean, variance, skewness, kurtosis)
p3 <- MyPoisson(lambda = c(1, 2.5, 5))
P3 <- Poisson(lambda = c(1, 2.5, 5))

## Class 'MyPoisson' knows the analytic cdf:
cdf(p3, x = 2)
identical(cdf(p3, x = 2), cdf(P3, x = 2))

## Calculating probability at x = 2
pdf(p3, x = 2) ## Numeric approximation
pdf(P3, x = 2) ## Analytic solution
pdf(p3, x = 2) - pdf(P3, x = 2) ## Pairwise differences/precision

## Calculating quantiles
probs <- c(0.0, 0.01, 0.25, 0.5, 0.75, 0.99, 1.0)
quantile(p3, probs = probs) ## Numeric approximation
quantile(P3, probs = probs) ## Analytic solution

probs2 <- seq(0.01, 0.99, by = 0.01)
qp3 <- quantile(p3, probs = probs2) ## Numeric approximation
qP3 <- quantile(P3, probs = probs2) ## Analytic solution
range(qp3 - qP3) ## Range of pairwise differences/precision

## Visual comparison
x <- seq(-1, 11, by = 1)
d <- data.frame(x = rep(x, times = 2),
                y = c(pdf(p3[2], x = x), pdf(P3[2], x = x)),
                solution = rep(c("approximated MyPoisson", "analytic Poisson"), each = length(x)))
ggplot(data = d, aes(x = x, y = y, fill = solution)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_manual(values = c("tomato", "black")) +
    labs(title = "Density (lambda = 5.0)")

probs <- seq(0.01, 0.99, by = 0.01)
d <- data.frame(x = c(quantile(p3[2], probs = probs), quantile(P3[2], probs = probs)),
                y = rep(probs, times = 2),
                solution = rep(c("approximated MyPoisson", "analytic Poisson"), each = length(probs)))
ggplot(data = d, aes(x = x, y = y, col = solution, lty = solution)) +
    geom_line(lwd = 1) +
    scale_color_manual(values = c("tomato", "black")) +
    labs(title = "Quantile function")

## Drawing random numbers
set.seed(6020)
d <- data.frame(x = c(random(p3[2], 500L), random(p3[2], 500L)),
                distribution = rep(c("approximated MyPoisson", "analytic Poisson"), each = 500L))
aggregate(x ~ distribution, data = d, FUN = function(x) c(mean = mean(x), var = var(x)))

freq <- as.data.frame(with(d, table(x, distribution))) # Calculating frequency
ggplot(data = freq, aes(x = x, y = Freq, fill = distribution)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_manual(values = 1:2) +
    labs(title = "Density of random numbers (lambda = 2.5)")

}
